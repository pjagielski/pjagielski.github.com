--- 
name: dont-repeat-spring-beans
title: Don't repeat the Spring beans!
time: 2010-11-25 15:52:00 +01:00
layout: post
---
The 'Don't repeat the DAO!' <a href="http://www.ibm.com/developerworks/java/library/j-genericdao.html">article</a> is a fundamental one for all Spring/ORM/Java world. The generic DAO pattern works well and is widely used in both commercial projects and open-source implementations. <br /><br />But what if you only need one class for all of your DAOs? In one of my projects I just needed to put all records from a database view to a file. I decided not to use an ORM, but just Spring's JdbcTemplate, configured by view name and column to use in ORDER BY section. So I started to write Spring XML wiring and realized.... that I'm repeating the Spring beans! Every declaration looked something like:<br /><pre class="brush:xml">&lt;bean id="customerDAO" class="pl.touk.blog.GenericDao"&gt;<br />     &lt;property name="table" value="V_CUSTOMERS"/&gt;<br />     &lt;property name="orderColumn" value="CUST_ID"/&gt;<br />  &lt;/bean&gt;<br /><br />  &lt;bean id="contractDAO" class="pl.touk.blog.GenericDao"&gt;<br />     &lt;property name="table" value="V_CONTRACTS"/&gt;<br />     &lt;property name="orderColumn" value="CONTRACT_ID"/&gt;<br />  &lt;/bean&gt;<br />...<br /></pre><br />There were about 15 twin beans in my Spring XML files! That looked really ugly...<br /><a name='more'></a><br /><span id="fullpost"><br />Googling a bit introduced to me concept of writing own Spring's BeanFactoryPostProcessor, in which I could instantiate DAOs and register them in CamelContext. My domain classes already had some annotations - I used  <a href="http://camel.apache.org/bindy.html">camel-bindy</a> component to specify output file format. So the idea was to write another annotation and pass DAOs configuration in it:<br /><br /><pre class="brush:java">@GenericDao(type = "customer", table = "V_CUSTOMERS", orderColumn = "CUST_ID")<br />public class Customer { ... }<br /><br />@GenericDao(type = "contract", table = "V_CONTRACTS", orderColumn = "CONTRACT_ID")<br />public class Contract { ... }<br /></pre><br />Then, the BeanFactoryPostProcessor could look like this:<br /><pre class="brush:java">public class GenericDaoBeanFactoryPostProcessor implements BeanFactoryPostProcessor {<br /><br />  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {<br />    Collection&lt;Class&lt;?&gt;&gt; classes = findClassesWithAnnotation(GenericDao.class); <br />    for (Class&lt;?&gt; c : classes) {<br />      GeneratedFile gfa = c.getAnnotation(GenericDao.class);<br />      String type = gfa.type();<br />      GenericDaoImpl dao = new GenericDaoImpl();<br />      dao.setDataSource(dataSource);<br />      dao.setClazz(c);<br />      dao.setTable(gfa.table());<br />      dao.setOrderColumn(gfa.orderColumn());<br />      beanFactory.registerSingleton(type + "Dao", dao);<br />    }<br />  } <br />}<br /></pre><br />So it seems to be rather easy. But what with findClassesWithAnnotation method? My first attempt was to use Camel's DefaultPackageScanClassResolver implementation, and it worked fine in my unit tests. But when I deployed the bundle within an OSGi container (Servicemix 4.0), no annotated classes were found at all... Looking inside DefaultPackageScanClassResolver implementation showed the reason:<br /><pre class="brush:java">// osgi bundles should be skipped<br /> if (url.toString().startsWith("bundle:") || urlPath.startsWith("bundle:")) {<br />   log.trace("It's a virtual osgi bundle, skipping");<br />   continue;<br /> } <br /></pre>Loading classes from bundle is an OSGi container-specific matter, and Camel correctly doesn't implement it (more precisely: there is an OsgiPackageScanClassResolver implementation, but it uses OSGi APIs).<br /><br />The solution is to use CamelContext's getPackageScanClassResolver() method to get correct resolver. In unit tests it returns default one, in OSGi environment - container-aware implementation.<br /><pre class="brush:java">public class GeneratedFileBeanFactoryPostProcessor implements BeanFactoryPostProcessor {<br />  protected CamelContext camelContext;<br /><br />  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {<br />    camelContext.getPackageScanClassResolver().findAnnotated(GenericDao.class, defaultPackage);<br />  ...<br />}<br /></pre><br />And now it works fine and Spring XML wirings look much better :)<br />Finally my route also uses PackageScanClassResolver to configure all endpoints:<br /><br /><pre class="brush:java">from("direct:start") <br />   .recipientList(constant(makeEndpointsFromTypes())  // makes 'direct:type' endpoint for all object types<br /><br />  for (String type: types) {<br />    from("direct:"+type).to("bean:"+type+"Dao?method=dumpAll")...<br />  }<br />  <br /></pre><br />PS. Sure, all of my classes could just subclass GenericDaoImpl, but I didn't want to mix database logic with the file structure logic. Using annotations feels a bit more like configuration, not implementation itself ;)<br /><br /></span>
